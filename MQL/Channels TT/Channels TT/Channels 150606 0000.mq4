//+------------------------------------------------------------------+
//|                                                     Channels.mq4 |
//|                                 Copyright 2015, Alexander Kretov |
//|                                             apkretov@hotmail.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2015, Alexander Kretov"
#property link      "apkretov@hotmail.com"
#property version   "1.00"
#property strict

extern int AllB=240; // кол-во баров для обсчета

int NB1=-1,NB2=-1,NB3,NB5;  // номера баров реперных точек
int Extrem=0; // индексы Экстремальных точек: Extrem = (0) - фрактал не найден, Extrem = (1)  - фрактал найден cверху, (любое положительное число), Extrem = (-1) - фрактал найден снизу   (любое отрицательное число)
int TestBar=0; // индекс тестируемого бара
double space; // расстояние от цены до "стрелки"
int B_F=0; // кол-во баров для фракталов в периоде
double Pr1=0,Pr2=0,Pr3,Pr5, // цены реперных баров с фракталами 
Tk1,Tk2,Tk3,Tk4,Tk5; // цены опорных точек для построения линий канала 
datetime Tm1,Tm2; // время баров опорных точек
double RatePr=0; // скорость изменения цены - pips/bars

//+------------------------------------------------------------------+
int OnInit() { // Expert initialization function
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
void OnDeinit(const int reason) { // Expert deinitialization function
   
}

//+------------------------------------------------------------------+
void OnTick() { // Expert tick function
   switch(Period()) { // кол-во баров для поиска фракталов по периодам    
      case 1:     B_F=12; space=0.0002; break;
      case 5:     B_F=48; space=0.0003; break;
      case 15:    B_F=24; space=0.0004; break;
      case 30:    B_F=24; space=0.0004; break;
      case 60:    B_F=12; space=0.0007; break;
      case 240:   B_F=15; space=0.0012; break;
      case 1440:  B_F=10; space=0.0030; break;
      case 10080: B_F=6;  space=0.0040; break;
   }
   TestBar = 2; // построим канал: //начинаем считать с третьего бара (считая "0"), чтобы мог "определиться фрактал" // номер тестируемого бара
   NB1 = -1; // считаем, что номера баров и экстремум не определены 
   NB2 = -1; 
   Extrem = 0;   
   while( ((NB1 == -1) || (NB2 == -1)) && (TestBar < AllB) ) { //w1 //  Если: - при Extrem меньше (1)(возможны два варианта: "0" и "-1"), //  и если индекс наименьшего значения цены совпадает с индексом исследуемого бара
      if( (Extrem < 1) && (TestBar == iLowest(Symbol(), Period(), MODE_LOW, B_F * 2 + 1, TestBar - B_F)) ) { //w2
         if(Extrem == 0) { //w3 // при варианте "0", когда на данный момент не было экстремума,
            Extrem = -1; // присвоим: найденной экстремальной точке значения (-1), отметив таким образом,  // что экстремум найден снизу, номер найденному бару (NB1) и значение цены (Pr1).   
            NB1 = TestBar; 
            Pr1 = Low[NB1]; } //-w3
         else if(Extrem != 0) { //w4 // первая точка была найдена раньше // иначе значения номера и цены будут присвоены точке 2
            NB2 = TestBar; 
            Pr2 = Low[NB2];
         } //-w4
         // для контроля можно вывести значения - Print("   # бара= ",NB2," знач.цены= ",Pr2); 
      } //-w2
      if((Extrem>-1) && (TestBar==iHighest(Symbol(),Period(),MODE_HIGH,B_F*2+1,TestBar-B_F))) { //w5 //  Если: - при Extrem больше (-1)(возможны: 0 и 1), и индекс наибольшего значения //  цены совпадает с номером исследуемого бара  - (по аналогии с выше изложенным)
         if(Extrem==0) { //w6 // если Extrem==0 
            Extrem=1; NB1=TestBar; Pr1=High[NB1]; } //-w6 // запомним номер бара (NB1) и значение цены (Pr1).
         else {//w7 // иначе значения номера и цены будут присвоены точке 2
            NB2=TestBar; Pr2=High[NB2];
         }//-w7
      } //-w5
      TestBar++;
   } //-w1
// -----------------------------------------------------------------------------------+
   if((NB1==-1) || (NB2==-1)) { // не нашли реперных точек на последних AllB барах
      //return(-1);
      return;
   }
// ---------------------------------	
   RatePr=(Pr2-Pr1)/(NB2-NB1); // Расчитаем скорость изменения цены. // если она положительная, то канал нисходящий, иначе восходящий.
// определим время реперных точек для линий канала
   Tm1=Time[0];    Tm2=Time[NB2+50];
// **************************************************************************************   
   if(Extrem==1) // если первым был найден экстремум сверху 
     {//1(Extrem=1)
      // имея две реперные точки и скорость изменения цены,
      // определим опорные точки этой линии:
      // первая опорная точка - проекция реперной точки на "0" бар
      double Tk1=Pr1-NB1*RatePr;
      // вторая опорная точка - проекция на левую сторону графика
      double Tk2=Tk1+(NB2+50)*RatePr;
      // Паралельно найденной линии построим противоположную линию канала.
      // Найдем реперную точку или точку привязки для противоположной линии канала:	
      // Примем за начало поиска минимальную цену 2-ого бара.
      Tk3=Low[2]-2*RatePr; // проекция 2-го бара на "0" бар	
      for(int i=3;i<=NB2;i++)  // поиск ведем начиная с 3-го бара  
        {//2(1)Up
         if(Low[i]<Tk3+i*RatePr) // по минимальному значению проекции цены на "0" баре
           {//3(1)Up
            Tk3=Low[i]-i*RatePr; // третья опорная точка (проекция на "0" бар)
            Pr5=Low[i];          // третья реперная точка для нижней линии канала
            NB5=i;               // номер бара третьей реперной точки
           }//-3(1)Up
        }//-2(1)Up
      // теперь посмотрим на первые два бара "0" и "1", их Min могут оказаться ниже 2-го бара
      // если учитывать корректировку построения канала по этим двум барам, то канал будет 
      // расширяться вслед за движением цены вниз, если не учитывать, то движение цены вниз 
      // можно рассматривать как прорыв линии канала (возможное зарождение тренда!)
      // if(Low[0]<Tk3) {Tk3=Low[0]; Pr5=Low[0]; NB5=0;}
      // if(Low[1]<Tk3+RatePr) {Tk3=Tk3+RatePr; Pr5=Low[1]; NB5=1;}
      datetime TmR1=Time[NB1];    datetime TmR2=Time[NB2];   datetime TmR5=Time[NB5];
      // ------------------------------------------------------------------------------------------
      // следующие орераторы только для визуального контроля работы программы(их можно удалить)
      // отображающие значения наклона канала, скорости, номера и время реперных точек при Extrem=1
      string TNB1=TimeToStr(TmR1,TIME_DATE|TIME_MINUTES);
      string TNB2=TimeToStr(TmR2,TIME_DATE|TIME_MINUTES);
      string TNB5=TimeToStr(TmR5,TIME_DATE|TIME_MINUTES);
      //   Print(" канал- ",SH," ; скорость = ",DoubleToStr(NormalizeDouble(RatePr,8),8),
      //         " pip / bar"," ; Extrem= ",Extrem);
      //   Print(" NB2= ",NB2," ; время= ",TNB2," ; NB5= ",NB5,
      //         " ; время= ",TNB5," ; NB1= ",NB1," ; время= ",TNB1);
      // ------------------------------------------------------------------------------------------
      // для наглядности исполнения программы пометим на графике реперные точки на линиях канала
      ObjectDelete("Rep1"); ObjectDelete("Rep2"); ObjectDelete("Rep3"); ObjectDelete("Rep5");
      ObjectCreate("Rep1",OBJ_ARROW,0,TmR1,Pr1+2*space);
      ObjectSet("Rep1",OBJPROP_COLOR,Yellow);
      ObjectSet("Rep1",OBJPROP_ARROWCODE,72);
      ObjectCreate("Rep2",OBJ_ARROW,0,TmR2,Pr2+2*space);
      ObjectSet("Rep2",OBJPROP_COLOR,Yellow);
      ObjectSet("Rep2",OBJPROP_ARROWCODE,72);
      ObjectCreate("Rep5",OBJ_ARROW,0,TmR5,Pr5-space);
      ObjectSet("Rep5",OBJPROP_COLOR,Yellow);
      ObjectSet("Rep5",OBJPROP_ARROWCODE,71);
      ObjectDelete("Cross2");
      // ------------------------------------------------------------------------------------------
      // расчитаем цены для координат опорных точек нижней границы канала:
      double Tk3=Pr5-RatePr*NB5; // цена нижней границы канала в "0" точке
      double Tk4=Tk3+RatePr*(NB2+50);// цена нижней границы канала в левой стороне графика
     }//- 1(Extrem=1)
// ******************************************************************************************
   else  if(Extrem==-1)// если первым был найден экстремум снизу 
     {//1(Extrem= -1)
      // цены опорных точек нижней границы канала:
      Tk3=Pr1-NB1*RatePr;      // в "0" точке
      Tk4=Tk3+(NB2+50)*RatePr; // в левой точке 
                               // Паралельно найденной линии построим противоположную линию канала.
      // Найдем реперную точку или точку привязки для противоположной линии канала.	
      // Примем за начало поиска цену 2-ого бара.
      Tk1=High[2]-2*RatePr; // проекция 2-го бара на "0" бар	
      for(int i=3;i<=NB2;i++) // поиск ведем начиная с 3-го бара
        {//2(-1)
         if(High[i]>Tk1+i*RatePr)
           {//3(-1)
            Tk1=High[i]-i*RatePr; // третья опорная точка (проекция на "0" бар)
            Pr3=High[i];          // третья реперная точка для верхней линии канала
            NB3=i;                // номер бара третьей реперной точки 
           }//-3(-1)
         // теперь посмотрим на первые два бара "0" и "1"
         // if(High[0]>Tk1) {Tk1=High[0]; Pr3=High[0]; NB3=0;}
         // if(High[1]>Tk1+RatePr) {Tk1=Tk1+RatePr; Pr3=High[1]; NB3=1;}
         TmR1=Time[NB1];    TmR2=Time[NB2];   datetime TmR3=Time[NB3];
        }//- 2(-1)
      // ---------------------------------------------------------------------------------
      // для контроля результатов выполнения введем следующие операторы 
      //(на работу программы они не влияют их можно удалить),
      // отображающие значения наклона (скорости) канала, скорости и номера 
      // и время реперных точек при Extrem = -1
      // TNB1=TimeToStr(TmR1,TIME_DATE|TIME_MINUTES);  
      // TNB2=TimeToStr(TmR2,TIME_DATE|TIME_MINUTES);
      // string TNB3=TimeToStr(TmR3,TIME_DATE|TIME_MINUTES);
      // Print(" канал- ",SH," ; скорость цены= ",DoubleToStr(NormalizeDouble(RatePr,8),8),
      //       " pip / bar"," ; Extrem= ",Extrem);
      // Print(" ; NB2= ",NB2," ; время= ",TNB2," ; NB3= ",NB3,
      //       " ; время= ",TNB3," ; NB1= ",NB1," ; время= ",TNB1);
      // ----------------------------------------------------------------------------------
      // для наглядности пометим на графике реперные точки на линиях канала
      ObjectDelete("Rep1"); ObjectDelete("Rep2");
      ObjectDelete("Rep3"); ObjectDelete("Rep5");
      ObjectCreate("Rep1",OBJ_ARROW,0,TmR1,Pr1-space);
      ObjectSet("Rep1",OBJPROP_COLOR,Yellow);
      ObjectSet("Rep1",OBJPROP_ARROWCODE,71);
      ObjectCreate("Rep2",OBJ_ARROW,0,TmR2,Pr2-space);
      ObjectSet("Rep2",OBJPROP_COLOR,Yellow);
      ObjectSet("Rep2",OBJPROP_ARROWCODE,71);
      ObjectCreate("Rep3",OBJ_ARROW,0,TmR3,Pr3+2*space);
      ObjectSet("Rep3",OBJPROP_COLOR,Yellow);
      ObjectSet("Rep3",OBJPROP_ARROWCODE,72);
      ObjectDelete("Cross1");
      // ---------------------------------------------------------------------------------------------    
      // расчитаем цены опорных точек верхней границы канала:
      Tk1=Pr3-RatePr*NB3; // цена верхней границы канала в "0" точке
      Tk2=Tk1+RatePr*(NB2+50);// цена верхней границы канала в левой точке
     }//-1(Extrem= -1)
// ---------------------------------=============================================================
// вычислим значения медианы канала и границ канала на последних 6-ти барах
   for(int i=0;i<6;i++)
     {
      TLUp_[i]=Tk1+i*RatePr;
      TLDn_[i]=Tk3+i*RatePr;
      Med_[i]=(TLUp_[i]+TLDn_[i])/2;
     }
}

//+------------------------------------------------------------------+
double OnTester() { // Tester function
   double ret=0.0;
   return(ret);
}
