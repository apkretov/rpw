#if 0

#include <array>
#include <future>
#include <map>
#include "../../stdafx.h"
using namespace std;

template <typename T>
class LazyValue {
	mutable optional<T> value;
	mutable mutex m;
	function<T()> init_;
public:
	explicit LazyValue(function<T()> init) : init_(std::move(init)) {} //TEST!
	bool HasValue() const { return value.has_value(); }

	const T &Get() const {
		if (lock_guard g(m); !value)
			value = init_();
		return *value;
	}
};

int main() {
	//map<string, int, less<>> city_population = {
	//	{"Москва", 10'000'000},
	//	{"CПб", 5'000'000},
	//	{"НСК", 2'000'000},
	//	{"Тула", 500'000}
	//};
	//LazyValue<map<string, int, less<>>> city_population_lv{[&] { return city_population; }};
	LazyValue<map<string, int, less<>>> city_population([&] { return map<string, int, less<>> {
		{"Москва", 10'000'000},
		{"CПб", 5'000'000},
		{"НСК", 2'000'000},
		{"Тула", 500'000},
#pragma region Excel generated cities
		{"Город 1", 1'000'000},
		{"Город 2", 1'000'000},
		{"Город 3", 1'000'000},
		{"Город 4", 1'000'000},
		{"Город 5", 1'000'000},
		{"Город 6", 1'000'000},
		{"Город 7", 1'000'000},
		{"Город 8", 1'000'000},
		{"Город 9", 1'000'000},
		{"Город 10", 1'000'000},
		{"Город 11", 1'000'000},
		{"Город 12", 1'000'000},
		{"Город 13", 1'000'000},
		{"Город 14", 1'000'000},
		{"Город 15", 1'000'000},
		{"Город 16", 1'000'000},
		{"Город 17", 1'000'000},
		{"Город 18", 1'000'000},
		{"Город 19", 1'000'000},
		{"Город 20", 1'000'000},
		{"Город 21", 1'000'000},
		{"Город 22", 1'000'000},
		{"Город 23", 1'000'000},
		{"Город 24", 1'000'000},
		{"Город 25", 1'000'000},
		{"Город 26", 1'000'000},
		{"Город 27", 1'000'000},
		{"Город 28", 1'000'000},
		{"Город 29", 1'000'000},
		{"Город 30", 1'000'000},
		{"Город 31", 1'000'000},
		{"Город 32", 1'000'000},
		{"Город 33", 1'000'000},
		{"Город 34", 1'000'000},
		{"Город 35", 1'000'000},
		{"Город 36", 1'000'000},
		{"Город 37", 1'000'000},
		{"Город 38", 1'000'000},
		{"Город 39", 1'000'000},
		{"Город 40", 1'000'000},
		{"Город 41", 1'000'000},
		{"Город 42", 1'000'000},
		{"Город 43", 1'000'000},
		{"Город 44", 1'000'000},
		{"Город 45", 1'000'000},
		{"Город 46", 1'000'000},
		{"Город 47", 1'000'000},
		{"Город 48", 1'000'000},
		{"Город 49", 1'000'000},
		{"Город 50", 1'000'000},
		{"Город 51", 1'000'000},
		{"Город 52", 1'000'000},
		{"Город 53", 1'000'000},
		{"Город 54", 1'000'000},
		{"Город 55", 1'000'000},
		{"Город 56", 1'000'000},
		{"Город 57", 1'000'000},
		{"Город 58", 1'000'000},
		{"Город 59", 1'000'000},
		{"Город 60", 1'000'000},
		{"Город 61", 1'000'000},
		{"Город 62", 1'000'000},
		{"Город 63", 1'000'000},
		{"Город 64", 1'000'000},
		{"Город 65", 1'000'000},
		{"Город 66", 1'000'000},
		{"Город 67", 1'000'000},
		{"Город 68", 1'000'000},
		{"Город 69", 1'000'000},
		{"Город 70", 1'000'000},
		{"Город 71", 1'000'000},
		{"Город 72", 1'000'000},
		{"Город 73", 1'000'000},
		{"Город 74", 1'000'000},
		{"Город 75", 1'000'000},
		{"Город 76", 1'000'000},
		{"Город 77", 1'000'000},
		{"Город 78", 1'000'000},
		{"Город 79", 1'000'000},
		{"Город 80", 1'000'000},
		{"Город 81", 1'000'000},
		{"Город 82", 1'000'000},
		{"Город 83", 1'000'000},
		{"Город 84", 1'000'000},
		{"Город 85", 1'000'000},
		{"Город 86", 1'000'000},
		{"Город 87", 1'000'000},
		{"Город 88", 1'000'000},
		{"Город 89", 1'000'000},
		{"Город 90", 1'000'000},
		{"Город 91", 1'000'000},
		{"Город 92", 1'000'000},
		{"Город 93", 1'000'000},
		{"Город 94", 1'000'000},
		{"Город 95", 1'000'000},
		{"Город 96", 1'000'000},
		{"Город 97", 1'000'000},
		{"Город 98", 1'000'000},
		{"Город 99", 1'000'000},
		{"Город 100", 1'000'000},
#pragma endregion //Excel generated cities
		{"Саратов", 1'000'000}}; });

	auto kernel = [&] { return city_population.Get().at("Тула"); };
	vector<future<int>> ts;
	for (size_t i = 0; i < 25; ++i)
		ts.push_back(async(kernel));
	for (auto &t : ts)
		t.get();

	const string saratov = "Саратов";
	static_cast<void>(setlocale(LC_ALL, "RU")); //MINE
	cout << saratov << ' ' << city_population.Get().at(saratov) << '\n';
}
#endif //1
